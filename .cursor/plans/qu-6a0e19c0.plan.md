<!-- 6a0e19c0-2e78-45e7-9220-eb59cc88b973 fd323b29-c753-4c07-9fb8-7a1d82ad536e -->
# План реализации Quicky

## 1. Архитектурное основание

- Сформировать структуру пакета `quicky/` с модулями `routing.py`, `types.py`, `handlers.py`, `serializers.py`, `middleware.py`, `di.py`, `runtime.py`, `metrics.py`, `cli.py`.
- Определить минимальные внешние зависимости (uvicorn, httptools, orjson) и интерфейсы взаимодействия с ASGI.
- Спроектировать API верхнего уровня (`app = Quicky()` + декораторы `@route`, `@get`, `@post`) с учётом zero-config.

## 2. Маршрутизация и сопоставление шаблонов

- Разработать таблицу маршрутов на основе структурного сопоставления (PEP 634): парсинг путей, HTTP-методов, поддержка приоритетов.
- Реализовать декларативные декораторы и DSL для path/query/body параметров (`Path[T]`, `Body[T]`, `Query[T]`).
- Добавить поддержку статических файлов и подроутеров (аналог FastAPI `APIRouter`).

## 3. Типовая система и валидация (PEP 695 + TypedDict)

- Построить модуль `types.py`, который инспектирует аннотации обработчиков и формирует схемы запросов/ответов.
- Имплементировать валидатор без Pydantic: использование `typing.get_type_hints`, `typing.Annotated`, `NotRequired`, `TypeAdapter`-подобные пайплайны для частичной валидации, вдохновляясь практиками Pydantic v2.
- Обеспечить генерацию человекочитаемых ошибок и reuse схем (кеширование).

## 4. Обработчики и DI

- В `handlers.py` реализовать конвейер: парсинг запроса → резолв зависимостей по типам параметров → вызов обработчика → нормализация ответа.
- Создать лёгкий DI-контейнер `di.py` с регистрацией провайдеров, scoping (request/app), ленивыми фабриками и асинхронной поддержкой.
- Добавить механизм background tasks / lifespan менеджера вместо on_event.

## 5. Сериализация и форматы ответа

- В `serializers.py` использовать `orjson` для JSON, fallback на `json` при ошибках; поддержать MessagePack/streaming генераторы.
- Нормализовать ответы (`dict`, `TypedDict`, `pydantic`-совместимые структуры, `StreamingResponse`).
- Реализовать content-negotiation и кастомные encoders.

## 6. Middleware и zero-config возможности

- Построить конвейер middleware (`middleware.py`) с упорядоченным стеком (CORS, gzip, structured logging, metrics, rate limiting hooks).
- Добавить API для регистрации пользовательских middleware и настройку по декларативным опциям (`app.use(middleware, **opts)`).
- Включить по умолчанию мониторинг запросов и structured logging (JSON + correlation ids).

## 7. Производительность и рантайм

- В `runtime.py` интегрировать Uvicorn с uvloop, протестировать несколько воркеров, graceful shutdown.
- Создать `cli.py` (например, `quicky run`) для zero-config старта, чтения `.env`, hot-reload.
- Реализовать benchmarking utility против FastAPI/Starlette для контроля цели «быстрее FastAPI».

## 8. Наблюдаемость и готовность к продакшену

- Экспортировать метрики Prometheus (latency, throughput, errors) в `metrics.py`.
- Добавить middleware трассировки (OpenTelemetry hooks) и structured error handling с user-friendly HTTPException аналогами.
- Подготовить базовую авто-документацию (минимальная OpenAPI схема) как мост к roadmap.

## 9. Roadmap расширения (v1.0.0 и далее)

- WebSocket слой с авто-переподключением и бэкендом очередей.
- GraphQL декоратор поверх Strawberry/Graphene (опционально) и shared schemas.
- Генерация OpenAPI + кодоген, встроенный rate limiting (`@app.limit`) с Redis.
- Плагины: `quicky-db`, `quicky-auth`, `quicky-testing` (описать интерфейсы плагинов и lifecycle hooks).

### To-dos

- [x] Определить структуру пакета quicky и зависимости
- [x] Спроектировать маршрутизатор и систему типов
- [x] Реализовать обработчик запросов и DI
- [x] Настроить сериализацию и middleware стек
- [x] Продумать рантайм, наблюдаемость и roadmap